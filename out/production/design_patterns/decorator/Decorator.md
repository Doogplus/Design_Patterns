# Decorator

## 动机（Motivation）
+ 在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；
并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。
+ 如何使“对象功能的扩展”能够根据需要来动态地实现？同时避免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变化”所导致的影响将为最低？

## 模式定义
动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码 & 减少子类个数）。
——《设计模式》GoF

## 要点总结
+ 通过采用组合而非继承的手法， Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。
避免了使用继承带来的“灵活性差”和“多子类衍生问题”。
+ Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。
但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类。
+ Decorator模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义。

***

## 图示
装饰者模式UML结构图
![pic](http://www.iocoder.cn/images/DegisnPattern/xiaomingge/20130522103956376)
> Component: 抽象构件。是定义一个对象接口，可以给这些对象动态地添加职责。
> ConcreteComponent:具体构件。是定义了一个具体的对象，也可以给这个对象添加一些职责。
> Decorator: 抽象装饰类。是装饰抽象类，继承了Component,从外类来扩展Component类的功能，但对于Component来说，是无需知道Decorator存在的。
> ConcreteDecorator:具体装饰类，起到给Component添加职责的功能。


情景模式：星巴兹以扩张速度快而闻名。在里面购买咖啡时，可以要求在其中加入各种调料，星巴兹会根据所加入的调料收取不同的费用，也就是说不同的咖啡与调料之间有N多不同的组合方式。每种咖啡和调料都有不同的收费。如果这个时候我们使用继承方式，则会陷入无以复加的地步。这里会有N多个类，出现“类爆炸”现象。
![pic](http://www.iocoder.cn/images/DegisnPattern/xiaomingge/20130522104050765)

使用装饰器模式之后：
![pic](http://www.iocoder.cn/images/DegisnPattern/xiaomingge/20130522104107517)

### *个人注解*
+ 问题的来源：因为层层继承，每层继承类呈阶乘规模增长，导致基类的代码大规模重复，每个类的复用性不高
+ 主要的原因是继承，将继承改为引用（继承Inherit -> 组合Composition）
  **即将类的继承改为成员变量的引用**
+ “同源继承方法向上抽象”——马丁富勒，即一个方法在多个同源继承类中存在应该向上提（提升到父类或接口中）--向上提的方法之一
+ 若父类派生出的子类有的不需要这个方法，说明这个方法对于父类来说不是必须的，但对多数子类有用：需要派生中间类——**装饰器Decorator**
+ 装饰器模式显著特征：**同时存在继承和组合**，继承-完善接口规范，组合-在运行时动态装载子类完成多态功能

*此文件中C++版本为授课用，标准GOF版设计模式思想的代码，java是我添加的*

### 其他人的笔记
[来源链接](http://www.iocoder.cn/DesignPattern/xiaomingge/Decorator-Pattern/)
> 四、装饰者模式的优缺点
>
>  优点
>  
>  1、装饰者模式可以提供比继承更多的灵活性 
>  ​2、可以通过一种动态的方式来扩展一个对象的功能，在运行时选择不同的装饰器，从而实现不同的行为。 
>  3、通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。 
>  4、具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。
> 
>  缺点
>
>  1、会产生很多的小对象，增加了系统的复杂性 
>  2、这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。 
>
>  五、装饰者模式的适用场景
>  ​1、在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。 
>  2、需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。
> 
>  六、总结
>
>  1、组合和委托可以在运行时动态的添加新的行为，而继承是静态的，在系统编译时就已经决定了对象的行为。 
>  2、装饰者模式意味着一群装饰者类，这些类用来包装具体组件 
>  3、装饰者可以在被装饰者的行为前面或者后面加上自己的行为，甚至可以将被装饰者的行为整个取代掉，从而达到特定的目的。 
>  4、可以用多个装饰者包装一个组件。 
>  5、装饰者一般对于组件的客户是透明的，除非客户程序依赖于组件的具体类型。 
>  6、装饰者会导致设计中出现许多的小对象，如果过度的使用，会让系统变得更加复杂。  
>  7、装饰者和被装饰者对象有相同的超类型。