# Abstract Factory

## 动机(motivation)
+ 在软件系统中，经常面临着“一系列相互依赖的对象工作”；同时，由于需求的变化，往往存在更多系列对象的创建工作。
+ 如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合。

## 模式定义
提供一个接口，让该接口负责创建一系列”相关或者相互依赖的对象“，无需指定它们具体的类。
——《设计模式》GoF

## 要点总结
+ 如果没有应对”多系列对象创建“的需求变化，则没有必要使用Abstract Factory模式，这时候使用简单的工厂即可。
+ ”系列对象“指的是在某一个特定系列的对象之间有相互依赖、或作用的关系。不同系列的对象之间不能相互依赖。
+ Abstract Factory模式主要在于应用”新系列“的需求变动。其缺点在与难以应对”新对象“的需求变动。

***

### *个人注解*
+ EmployeeDAO3是在2的基础上更改，思路是，既然每套数据库都需要`Connection,Command,DataReader`三个对象，因此分开创建会导致匹配不一致的问题。
  所以EmployeeDAO3将三个类工厂合并成一个工厂，每生成一个对象自动匹配创建一套3个相关对象。
+ 理解：**抽象工厂就是一个工厂创建一组相互关联的对象**

![pic](https://upload-images.jianshu.io/upload_images/4119448-e9de70406001a6b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)

*类图中虚线连接的表示为有关联的类*

### 其他人的笔记
[原文链接](https://github.com/JamesZBL/java_design_patterns/tree/master/abstract-factory)
#### 抽象工厂模式适用场景

> * 一个系统应该独立于其产品是如何创建、组合和表示的
> * 一个系统需要配置多个系列中的一种产品
> * 一个相关产品对象的集合被设计用于一起使用，并且需对这个集合进行约束
> * 关于一个类的产品，使用者要特别关注它们的接口，而不是它们的实现
> * 依赖关系的生命周期理论上比使用者的生命周期短
> * 需要一个在运行时才能确定的参数来构造一个特定的依赖对象
> * 需要在运行时决定从一个集合中调用哪个系列的产品
> * 需要提供若干个只在运行时才知道的参数，然后才能解决依赖关系